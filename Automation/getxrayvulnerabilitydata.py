
import argparse
import datetime as dt
from datetime import datetime
import json
import os
import pandas as pd
import requests
import sys
import time
from requests.auth import HTTPBasicAuth
from zipfile import ZipFile
from io import BytesIO


# Update variables as needed
SOURCE_JPD_URL=""
JPD_TOKEN=""
REPORT_NAME = "report"
COLUMN_LIST = ['CVES', 'CVSS3 score', 'CVSS2 score', 'Summary', 'Fixed versions', 'Package type', 'Severity', 'Published', 'Impacted Artifact', 'Path', 'Artifact Scan Time', 'References', 'Description']
CHUNK_SIZE = 10000
#variables
CONDITION_All = "all"


# headers
headers_json = {
            "Authorization": "Bearer "+JPD_TOKEN,
            "Accept": "application/json",
            "Content-Type": "application/json"
            }

headers_text = {
            "Authorization": "Bearer "+JPD_TOKEN,
            "Accept": "text/plain",
            "Content-Type": "text/plain"
            }

#request template for generating vulnerability report
request_data = {
    "name": "xray_report1",
    "resources": {
        "repositories": [

        ]
    },
    "filters": {
        "vulnerable_component": "",
        "impacted_artifact": "",
        "has_remediation": True,
        "cve": "",
        "issue_id": "",
        "severities": [
        ],
        "cvss_score": {
            "min_score": 0,
            "max_score": 10
        },
        "published": {
            
        },
        "scan_date": {
            
        }

        }

    }

# Python program to match wild card characters 
  
# The main function that checks if two given strings match. 
# The first string may contain wildcard characters 
def match(first, second): 
  
    # If we reach at the end of both strings, we are done 
    if len(first) == 0 and len(second) == 0: 
        return True
  
    # Make sure to eliminate consecutive '*' 
    if len(first) > 1 and first[0] == '*': 
        i = 0
        while i+1 < len(first) and first[i+1] == '*': 
            i = i+1
        first = first[i:] 
  
    # Make sure that the characters after '*' are present 
    # in second string. This function assumes that the first 
    # string will not contain two consecutive '*' 
    if len(first) > 1 and first[0] == '*' and len(second) == 0: 
        return False
  
    # If the first string contains '?', or current characters 
    # of both strings match 
    if (len(first) > 1 and first[0] == '?') or (len(first) != 0
                                                and len(second) != 0 and first[0] == second[0]): 
        return match(first[1:], second[1:]) 
  
    # If there is *, then there are two possibilities 
    # a) We consider current character of second string 
    # b) We ignore current character of second string. 
    if len(first) != 0 and first[0] == '*': 
        return match(first[1:], second) or match(first, second[1:]) 
  
    return False

# print json response
def printjsonresponse(response):
    data=response.json()
    rep_str = json.dumps(data, indent=4)
    #print(rep_str)
    return rep_str


# Validate scan date
def validatescandate(date_text):
    """
    Validates scan_date is valid or not.

    Args:
        date_text (str): The scan date.
    """
    try:
        if date_text != datetime.strptime(date_text, '%Y-%m-%d').strftime('%Y-%m-%d'):
            print("Invalid date time format, format should be YYYY-MM-DD")
            raise ValueError
        else:
            print("valid time")
        return True
    except ValueError:
        return False

# Validate input parameters 
def validateinputdata(reponame,cvss_score,scan_date):
    """
    Validates input parameters.

    Args:
        reponame (str): The repository name for which vulnerabilities report to be generated.
        cvss_score (int): The CVSS score. (*All/<=n)
        scan_date (date): The date after which vulnerabilities are detected (*All/Discovered after (yyyy-mm-dd))
    """
    print("----validateinputdata----start")
    print("Validating input data ")
    
    # Validate reponame
    if not isinstance(reponame, str):
        print("Please enter valid repository name " + reponame)
        sys.exit()
    else:
        print("repository name is Ok " + reponame)
    
    # Validate cvss score
    if cvss_score != None: 
        if cvss_score.lower() == CONDITION_All:
            print("cvss score is Ok " + str(cvss_score))
        else:
            #check if entered cvss score is within valid range
            try:
                cvss_score = int(cvss_score)
                print("validate input data cvss.....")
                r = range(0, 11)
                if cvss_score not in r:
                    # cvss score is invalid
                    sys.exit()
                else:
                    print("cvss score is Ok " + str(cvss_score))
            except:
                print("Please enter valid cvss score All/0-10 " + str(cvss_score))
                sys.exit()

    # Validate scan date
    if scan_date != None:
        if scan_date.lower() == CONDITION_All:
            print("scan date is Ok " + scan_date)
        else:
            validdate = validatescandate(scan_date)
            if validdate == False:
                print("scan_date is not in correct format. Please enter <YYYY-MM-DD> format")
                sys.exit()
    print("----validateinputdata----end")

# Generate vulnerability report
def generatereport(modified_json_data,headers):
    print("----generatereport----start")
    try:
         # Generate a vulnerability report based on date and cvss_score
        response = requests.post(SOURCE_JPD_URL+ "/xray/api/v1/reports/vulnerabilities",  data=modified_json_data,  headers=headers)
        rep_str = printjsonresponse(response)

        if (response.status_code==200):
            print("xray vulnerabilty report generation is started "  + rep_str)
        else: 
            print("xray vulnerabilty report generation status is  " + rep_str)
        print()
        report_response = json.loads(rep_str)

        print("----generatereport----end")
        return report_response
    except BaseException as e:
        print(" Failed to generate report, exception : "+ str(e))

# Get artifact list in repository
def getartifactsinrepo(reponame, headers):
    try:
        print("----getartifactsinrepo----start")
        artifactlist = ""
        artifacts_in_repo = 'items.find({"repo":"' + reponame + '"}).include("repo","path","name","created").sort({"$asc" : ["created"]})'

        response = requests.post(SOURCE_JPD_URL+ "/artifactory/api/search/aql" , data=artifacts_in_repo, headers=headers)
        if(response.status_code== 200):
            artifactlist = printjsonresponse(response)
        else:
            print ("Unable get artifacts from repository " + reponame)
            print(response.text)
        print("----getartifactsinrepo----end")
        return artifactlist

    except BaseException as e:
        print(" Failed to get artifacts in repository, exception : "+ str(e))

# Export vulnerability report
def exportreport(report_id, headers,reportname):
    """
    Export vulnerability report.

    Args:
        report_id (int): The id of vulnerability report.
        headers (type): The headers
        reportname (string): The name of vulnerability report
    """
    print("----exportreport----start")
    try:

        # Export CSV report
        print("xray vulnerability data is available getting details.....")
        response = requests.get(SOURCE_JPD_URL+ "/xray/api/v1/reports/export/" + str(report_id) + "?file_name=xray_vulnerability_report&format=csv", headers=headers)

        if response.status_code == 200:
            print("Exported vulnerability report successfully")
            # response is ZIP file stream
            current_workdir = os.getcwd()
            file = ZipFile(BytesIO(response.content))
            df = pd.read_csv(file.open("xray_vulnerability_report.csv"))

            df = df[COLUMN_LIST]
            #print to console
            df.to_csv(sys.stdout, index=False)

            #print to csv file 
            df.to_csv(reportname +".csv", sep='\t', encoding='utf-8', index=False, header=True)

        else:
            print("Failed to export vulnerability report " + str(response.status_code))

        print("----exportreport----end")

    except BaseException as e:
        print("Failed to export vulnerability report, exception : "+ str(e))

# Delete vulnerability report
def deletereport(report_id):
    """
    Delete vulnerability report.

    Args:
        report_id (int): The id of vulnerability report.
    """
    print("----deletereport----start")
    try:
        print("Deleting report after export")
        response = requests.delete(SOURCE_JPD_URL+ "/xray/api/v1/reports/" + str(report_id), headers=headers_json)

        if response.status_code == 200:
            print("Report deletion status :" + str(response))
        else:
            print("Failed to delete vulnerability report with id  " + str(report_id) + str(response))

        print("----deletereport----end")


    except BaseException as e:
        print("Failed to delete report, exception : "+ str(e))

# Check status of vulnerability report
def checkstatusofreport(report_id, headers):
    """
    Check status of vulnerability report.

    Args:
        report_id (int): The id of vulnerability report.
        headers (type): The headers
    """
    try:

        while True:
            
            print("checking status of report.....")
            # Get Report details by ID
            response = requests.get(SOURCE_JPD_URL+ "/xray/api/v1/reports/"+ str(report_id),  headers=headers)
            rep_status_str = printjsonresponse(response)
            
            report_details_json = json.loads(rep_status_str)
            print (report_details_json)

            print("report status : " + report_details_json["status"])
    
            if report_details_json['status'] == "completed":
                print("Vulnerability report is generated successfully")
                break
            elif report_details_json['status'] == "pending":
                print("Vulnerability report is pending ....")
            elif report_details_json['status'] == "running":
                print("Vulnerability report is running ....")
            elif report_details_json['status'] == "aborted":
                print("Vulnerability report generation is aborted....")
                break
            elif report_details_json['status'] == "failed":
                print("Vulnerability report generation is failed....")
                break
            time.sleep(60) # sixty second delay

    except BaseException as e:
        print("Failed to check status of report, exception : "+ str(e))

# Process request
def updaterequest(request_json_data, reponame,cvss_score,scan_date,chunknumber):
    """
    Process request.

    Args:
        request_json_data (json): The template json for request
        reponame (str): The repository name for which vulnerabilities report to be generated.
        cvss_score (int): The CVSS score. (*All/<=n)
        scan_date (date): The date after which vulnerabilities are detected (*All/Discovered after (yyyy-mm-dd))
        chunknumber (int): The chunk id
    """
    #
    print("----updaterequest----start")
    print("call updaterequest")
    try:
        
        pattern=[]

        #Get current date and time
        current_date_time = dt.datetime.now()
        current_date_time_frmt = current_date_time.strftime("%Y-%m-%dT%H:%M:%SZ")
        print("current date : " + current_date_time_frmt )

        # update cvss_score
        if cvss_score.lower() == CONDITION_All:
            print("cvss score is set to 0-10")
        else:
            request_json_data["filters"]["cvss_score"]["min_score"]  = int(cvss_score)
            print("cvss score is set to :" + cvss_score + " in request")
        print()
        
        #update scan end date
        request_json_data["filters"]["scan_date"]["end"]  = current_date_time_frmt
        
        if scan_date.lower() == CONDITION_All:
            print("scan date All")       
        else: 
            
            # Convert date to required format for response
            scan_date = datetime.strptime(scan_date + "T00:00:00Z", "%Y-%m-%dT%H:%M:%SZ").strftime('%Y-%m-%dT%H:%M:%SZ')
            request_json_data["filters"]["scan_date"]["start"]  = scan_date
            print("scan date is set to :" + scan_date + " in request")
        print()
        
        # get artifacts count in repository
        print(reponame)
        artifactlist = getartifactsinrepo(reponame, headers_text)
        artifactslistjson = json.loads(artifactlist)
        print("artifacts count in repo "  + str(reponame) + " : " + str(artifactslistjson["range"]["total"]) )

        for i in range(0, artifactslistjson["range"]["total"], CHUNK_SIZE):
            print("getting chunk")
            # get the chunk list to process
            result=artifactslistjson["results"][i:i+CHUNK_SIZE]

            # update report name
            reportname= reponame + REPORT_NAME + "_" + str(chunknumber) + "_" + str(current_date_time.strftime("%Y%m%d%H%M%S"))
            request_json_data["name"] = reportname

            chunknumber= chunknumber + 1
            # To view chunk uncomment below line
            # print(json.dumps(result, indent=4))
            print()
            
            startindex=0
            endindex=len(result)-1
            # get start and end created date in chunk
            startdate = result[startindex]["created"]
            print("start date in chunk : " + startdate)
            
            enddate = result[endindex]["created"]
            print("end date in chunk : " +  enddate)
            
            print()
            # update published start and end dates
            request_json_data["filters"]["published"]["start"]= startdate
            request_json_data["filters"]["published"]["end"]= enddate
            
            # Convert the modified data back to JSON
            modified_json_data = json.dumps(request_json_data)
            print('Sending request :' +  modified_json_data)
            
            # Send a request to generate report
            report_response = generatereport(modified_json_data, headers_json )

            report_id = report_response["report_id"]
            report_status = report_response["status"]
             
            # check status of report
            checkstatusofreport(report_id, headers_json )
            print()

            # export report
            exportreport(report_id, headers_json, reportname)

            #delete report
            deletereport(report_id)
            print("----updaterequest----end")
            
    except BaseException as e:
        print(" Failed in updaterequest, exception : "+ str(e))
    

# Main function
def main():
    """
    Main function to get xray vulnerability data. Parses command-line arguments and orchestrates the workflow.
    """
    print("----main----start")
    print("Executing getxrayvulnerabiltydata script ")
    print()
    parser = argparse.ArgumentParser(description="Get xray vulnerability data")
    parser.add_argument("reponame", help="JFrog base URL")
    parser.add_argument("cvss_score", nargs='?', help="<Optional> Common vulnerability scoring system All/<=n")
    parser.add_argument("scan_date", nargs='?', help="<Optional> The date after which scan was performed")

    args = parser.parse_args()
    reponame = args.reponame
    cvss_score = args.cvss_score
    scan_date = args.scan_date
    
    #validate
    validateinputdata(reponame,cvss_score,scan_date)
    print()

    chunknumber=0
    foundMatchingrepo=""
    try:

        # check for wildcards
        if reponame.endswith('*') or reponame.endswith('?'):
            print("repo name has wildcards....")
            # Get list of available repositories
            response = requests.get(SOURCE_JPD_URL+ "/artifactory/api/repositories?type=local", headers=headers_json)
            data=response.json()
            rep_str = json.dumps(data, indent=4)
            if response.status_code == 200:
                for i in data:
                    matched_reponame = i["key"]
                    if match(reponame, matched_reponame):
                        foundMatchingrepo=matched_reponame
                        #Load a new request template for each repository.we check chunk based on repo
                        req_data = json.dumps(request_data)
                        request_json_data = json.loads(req_data)
                        #print(request_json_data)
                        # update repository name
                        request_json_data["resources"]["repositories"].append({"name": matched_reponame})
                        print()
                        print("repository name is set to : " + matched_reponame + " in request")
                        updaterequest(request_json_data, matched_reponame,cvss_score, scan_date, chunknumber) 
                if foundMatchingrepo =="":
                    print("No match found for repository")
            else:
                print("Error getting local repositories "+ str(response.text))
                
        else:
            # Load the request template
            req_data = json.dumps(request_data)
            request_json_data = json.loads(req_data)
            # update repository name
            request_json_data["resources"]["repositories"].append({"name": reponame})
            print()
            print("repository name is set to : " + reponame + " in request")
            updaterequest(request_json_data,reponame,cvss_score,scan_date, chunknumber)
            
        print("----main----end")
        
    except BaseException as e:
        print(" Failed to execute script, exception : "+ str(e))

if __name__ == "__main__":
    main()

# Usage 
# python getxrayvulnerabilitydata.py <reponame> <cvss_score> <scan_date>

# Example
# python getxrayvulnerabilitydata.py blr-docker-ps-td 10 2024-08-26
